"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
Proto 2 test file."""

from collections import abc as _abc
from google.protobuf import descriptor as _descriptor
from google.protobuf import empty_pb2 as _empty_pb2
from google.protobuf import message as _message
from google.protobuf.internal import containers as _containers
from google.protobuf.internal import enum_type_wrapper as _enum_type_wrapper
from google.protobuf.internal import extension_dict as _extension_dict
from test import test_generated_mypy as _test_generated_mypy
from testproto import nopackage_pb2 as _nopackage_pb2
from testproto import test3_pb2 as _test3_pb2
from testproto.inner import inner_pb2 as _inner_pb2
from testproto.inner import test3_pb2 as _test3_pb2_1
from testproto.nested import nested_pb2 as _nested_pb2
import builtins as _builtins
import sys
import typing as _typing

if sys.version_info >= (3, 10):
    from typing import TypeAlias as _TypeAlias
else:
    from typing_extensions import TypeAlias as _TypeAlias

if sys.version_info >= (3, 13):
    from warnings import deprecated as _deprecated
else:
    from typing_extensions import deprecated as _deprecated

DESCRIPTOR: _descriptor.FileDescriptor

class _OuterEnum:
    ValueType = _typing.NewType("ValueType", _builtins.int)
    V: _TypeAlias = ValueType  # noqa: Y015

class _OuterEnumEnumTypeWrapper(_enum_type_wrapper._EnumTypeWrapper[_OuterEnum.ValueType], _builtins.type):
    DESCRIPTOR: _descriptor.EnumDescriptor
    FOO: _OuterEnum.ValueType  # 1
    """FOO"""
    BAR: _OuterEnum.ValueType  # 2
    """BAR"""

class OuterEnum(_OuterEnum, metaclass=_OuterEnumEnumTypeWrapper):
    """Outer Enum"""

FOO: OuterEnum.ValueType  # 1
"""FOO"""
BAR: OuterEnum.ValueType  # 2
"""BAR"""
Global___OuterEnum: _TypeAlias = OuterEnum  # noqa: Y015

class _NamingConflicts:
    ValueType = _typing.NewType("ValueType", _builtins.int)
    V: _TypeAlias = ValueType  # noqa: Y015

class _NamingConflictsEnumTypeWrapper(_enum_type_wrapper._EnumTypeWrapper[_NamingConflicts.ValueType], _builtins.type):
    DESCRIPTOR: _descriptor.EnumDescriptor

class NamingConflicts(_NamingConflicts, metaclass=_NamingConflictsEnumTypeWrapper):
    """Naming conflicts!"""

Name: NamingConflicts.ValueType  # 1
Value: NamingConflicts.ValueType  # 2
keys: NamingConflicts.ValueType  # 3
values: NamingConflicts.ValueType  # 4
items: NamingConflicts.ValueType  # 5
"""See https://github.com/protocolbuffers/protobuf/issues/8803
proto itself generates broken code when DESCRIPTOR is there
DESCRIPTOR = 8;
"""
Global___NamingConflicts: _TypeAlias = NamingConflicts  # noqa: Y015

class _DeprecatedEnum:
    ValueType = _typing.NewType("ValueType", _builtins.int)
    V: _TypeAlias = ValueType  # noqa: Y015

class _DeprecatedEnumEnumTypeWrapper(_enum_type_wrapper._EnumTypeWrapper[_DeprecatedEnum.ValueType], _builtins.type):
    DESCRIPTOR: _descriptor.EnumDescriptor
    @_builtins.property
    @_deprecated("""This enum value has been marked as deprecated using proto enum value options.""")
    def DEPRECATED_ONE(self) -> _DeprecatedEnum.ValueType:   # 1
        """Trailing comment for enum value"""
    @_builtins.property
    @_deprecated("""This enum value has been marked as deprecated using proto enum value options.""")
    def DEPRECATED_TWO(self) -> _DeprecatedEnum.ValueType: ...  # 2
    NOT_DEPRECATED: _DeprecatedEnum.ValueType  # 3

@_deprecated("""This enum is deprecated\n2 lines of comments\n"Quotes in comments"\nand 'single quotes'\nTrailing comment""")
class DeprecatedEnum(_DeprecatedEnum, metaclass=_DeprecatedEnumEnumTypeWrapper): ...

DEPRECATED_ONE: DeprecatedEnum.ValueType  # 1
"""Trailing comment for enum value"""
DEPRECATED_TWO: DeprecatedEnum.ValueType  # 2
NOT_DEPRECATED: DeprecatedEnum.ValueType  # 3
Global___DeprecatedEnum: _TypeAlias = DeprecatedEnum  # noqa: Y015

@_typing.final
class Simple1(_message.Message):
    """Message with one of everything"""

    DESCRIPTOR: _descriptor.Descriptor

    class _InnerEnum:
        ValueType = _typing.NewType("ValueType", _builtins.int)
        V: _TypeAlias = ValueType  # noqa: Y015

    class _InnerEnumEnumTypeWrapper(_enum_type_wrapper._EnumTypeWrapper[Simple1._InnerEnum.ValueType], _builtins.type):
        DESCRIPTOR: _descriptor.EnumDescriptor
        INNER1: Simple1._InnerEnum.ValueType  # 1
        """INNER1"""
        INNER2: Simple1._InnerEnum.ValueType  # 2
        """INNER2"""

    class InnerEnum(_InnerEnum, metaclass=_InnerEnumEnumTypeWrapper):
        """Inner Enum"""

    INNER1: Simple1.InnerEnum.ValueType  # 1
    """INNER1"""
    INNER2: Simple1.InnerEnum.ValueType  # 2
    """INNER2"""

    @_typing.final
    class InnerMessage(_message.Message):
        DESCRIPTOR: _descriptor.Descriptor

        def __init__(
            self,
        ) -> None: ...

    @_typing.final
    class EmailByUidEntry(_message.Message):
        DESCRIPTOR: _descriptor.Descriptor

        KEY_FIELD_NUMBER: _builtins.int
        VALUE_FIELD_NUMBER: _builtins.int
        key: _builtins.int
        value: _builtins.str
        def __init__(
            self,
            *,
            key: _builtins.int | None = ...,
            value: _builtins.str | None = ...,
        ) -> None: ...
        _HasFieldArgType: _TypeAlias = _typing.Literal["key", b"key", "value", b"value"]  # noqa: Y015
        def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
        _ClearFieldArgType: _TypeAlias = _typing.Literal["key", b"key", "value", b"value"]  # noqa: Y015
        def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

    A_STRING_FIELD_NUMBER: _builtins.int
    A_REPEATED_STRING_FIELD_NUMBER: _builtins.int
    A_BOOLEAN_FIELD_NUMBER: _builtins.int
    A_UINT32_FIELD_NUMBER: _builtins.int
    A_ENUM_FIELD_NUMBER: _builtins.int
    A_EXTERNAL_ENUM_FIELD_NUMBER: _builtins.int
    A_INNER_FIELD_NUMBER: _builtins.int
    A_NESTED_FIELD_NUMBER: _builtins.int
    INNER_ENUM_FIELD_NUMBER: _builtins.int
    REP_INNER_ENUM_FIELD_NUMBER: _builtins.int
    INNER_MESSAGE_FIELD_NUMBER: _builtins.int
    REP_INNER_MESSAGE_FIELD_NUMBER: _builtins.int
    NO_PACKAGE_FIELD_NUMBER: _builtins.int
    NESTED_ENUM_FIELD_NUMBER: _builtins.int
    NESTED_MESSAGE_FIELD_NUMBER: _builtins.int
    A_ONEOF_1_FIELD_NUMBER: _builtins.int
    A_ONEOF_2_FIELD_NUMBER: _builtins.int
    OUTER_MESSAGE_IN_ONEOF_FIELD_NUMBER: _builtins.int
    OUTER_ENUM_IN_ONEOF_FIELD_NUMBER: _builtins.int
    INNER_ENUM_IN_ONEOF_FIELD_NUMBER: _builtins.int
    USER_ID_FIELD_NUMBER: _builtins.int
    EMAIL_FIELD_NUMBER: _builtins.int
    EMAIL_BY_UID_FIELD_NUMBER: _builtins.int
    PROPERTY_FIELD_NUMBER: _builtins.int
    COLLECTIONS_FIELD_NUMBER: _builtins.int
    TESTPROTO_FIELD_NUMBER: _builtins.int
    EMPTY_FIELD_NUMBER: _builtins.int
    SYS_FIELD_NUMBER: _builtins.int
    a_string: _builtins.str
    a_boolean: _builtins.bool
    a_uint32: _builtins.int
    a_enum: Global___OuterEnum.ValueType
    a_external_enum: _test3_pb2.OuterEnum.ValueType
    inner_enum: Global___Simple1.InnerEnum.ValueType
    nested_enum: _nested_pb2.AnotherNested.NestedEnum.ValueType
    a_oneof_1: _builtins.str
    a_oneof_2: _builtins.str
    outer_enum_in_oneof: Global___OuterEnum.ValueType
    inner_enum_in_oneof: Global___Simple1.InnerEnum.ValueType
    user_id: _test_generated_mypy.UserId
    email: _test_generated_mypy.Email
    property: _builtins.str
    collections: _builtins.str
    testproto: _builtins.str
    sys: _builtins.str
    @_builtins.property
    def a_repeated_string(self) -> _containers.RepeatedScalarFieldContainer[_builtins.str]: ...
    @_builtins.property
    def a_inner(self) -> _inner_pb2.Inner: ...
    @_builtins.property
    def a_nested(self) -> _nested_pb2.Nested: ...
    @_builtins.property
    def rep_inner_enum(self) -> _containers.RepeatedScalarFieldContainer[Global___Simple1.InnerEnum.ValueType]: ...
    @_builtins.property
    def inner_message(self) -> Global___Simple1.InnerMessage: ...
    @_builtins.property
    def rep_inner_message(self) -> _containers.RepeatedCompositeFieldContainer[Global___Simple1.InnerMessage]: ...
    @_builtins.property
    def no_package(self) -> _nopackage_pb2.NoPackage: ...
    @_builtins.property
    def nested_message(self) -> _nested_pb2.AnotherNested.NestedMessage: ...
    @_builtins.property
    def outer_message_in_oneof(self) -> Global___Simple2: ...
    @_builtins.property
    def email_by_uid(self) -> _containers.ScalarMap[_test_generated_mypy.UserId, _test_generated_mypy.Email]: ...
    @_builtins.property
    def empty(self) -> _empty_pb2.Empty: ...
    def __init__(
        self,
        *,
        a_string: _builtins.str | None = ...,
        a_repeated_string: _abc.Iterable[_builtins.str] | None = ...,
        a_boolean: _builtins.bool | None = ...,
        a_uint32: _builtins.int | None = ...,
        a_enum: Global___OuterEnum.ValueType | None = ...,
        a_external_enum: _test3_pb2.OuterEnum.ValueType | None = ...,
        a_inner: _inner_pb2.Inner | None = ...,
        a_nested: _nested_pb2.Nested | None = ...,
        inner_enum: Global___Simple1.InnerEnum.ValueType | None = ...,
        rep_inner_enum: _abc.Iterable[Global___Simple1.InnerEnum.ValueType] | None = ...,
        inner_message: Global___Simple1.InnerMessage | None = ...,
        rep_inner_message: _abc.Iterable[Global___Simple1.InnerMessage] | None = ...,
        no_package: _nopackage_pb2.NoPackage | None = ...,
        nested_enum: _nested_pb2.AnotherNested.NestedEnum.ValueType | None = ...,
        nested_message: _nested_pb2.AnotherNested.NestedMessage | None = ...,
        a_oneof_1: _builtins.str | None = ...,
        a_oneof_2: _builtins.str | None = ...,
        outer_message_in_oneof: Global___Simple2 | None = ...,
        outer_enum_in_oneof: Global___OuterEnum.ValueType | None = ...,
        inner_enum_in_oneof: Global___Simple1.InnerEnum.ValueType | None = ...,
        user_id: _test_generated_mypy.UserId | None = ...,
        email: _test_generated_mypy.Email | None = ...,
        email_by_uid: _abc.Mapping[_test_generated_mypy.UserId, _test_generated_mypy.Email] | None = ...,
        property: _builtins.str | None = ...,
        collections: _builtins.str | None = ...,
        testproto: _builtins.str | None = ...,
        empty: _empty_pb2.Empty | None = ...,
        sys: _builtins.str | None = ...,
    ) -> None: ...
    _HasFieldArgType: _TypeAlias = _typing.Literal["a_boolean", b"a_boolean", "a_enum", b"a_enum", "a_external_enum", b"a_external_enum", "a_inner", b"a_inner", "a_nested", b"a_nested", "a_oneof", b"a_oneof", "a_oneof_1", b"a_oneof_1", "a_oneof_2", b"a_oneof_2", "a_string", b"a_string", "a_uint32", b"a_uint32", "collections", b"collections", "email", b"email", "empty", b"empty", "inner_enum", b"inner_enum", "inner_enum_in_oneof", b"inner_enum_in_oneof", "inner_message", b"inner_message", "nested_enum", b"nested_enum", "nested_message", b"nested_message", "no_package", b"no_package", "outer_enum_in_oneof", b"outer_enum_in_oneof", "outer_message_in_oneof", b"outer_message_in_oneof", "property", b"property", "sys", b"sys", "testproto", b"testproto", "user_id", b"user_id"]  # noqa: Y015
    def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["a_boolean", b"a_boolean", "a_enum", b"a_enum", "a_external_enum", b"a_external_enum", "a_inner", b"a_inner", "a_nested", b"a_nested", "a_oneof", b"a_oneof", "a_oneof_1", b"a_oneof_1", "a_oneof_2", b"a_oneof_2", "a_repeated_string", b"a_repeated_string", "a_string", b"a_string", "a_uint32", b"a_uint32", "collections", b"collections", "email", b"email", "email_by_uid", b"email_by_uid", "empty", b"empty", "inner_enum", b"inner_enum", "inner_enum_in_oneof", b"inner_enum_in_oneof", "inner_message", b"inner_message", "nested_enum", b"nested_enum", "nested_message", b"nested_message", "no_package", b"no_package", "outer_enum_in_oneof", b"outer_enum_in_oneof", "outer_message_in_oneof", b"outer_message_in_oneof", "property", b"property", "rep_inner_enum", b"rep_inner_enum", "rep_inner_message", b"rep_inner_message", "sys", b"sys", "testproto", b"testproto", "user_id", b"user_id"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...
    _WhichOneofReturnType_a_oneof: _TypeAlias = _typing.Literal["a_oneof_1", "a_oneof_2", "outer_message_in_oneof", "outer_enum_in_oneof", "inner_enum_in_oneof"]  # noqa: Y015
    _WhichOneofArgType_a_oneof: _TypeAlias = _typing.Literal["a_oneof", b"a_oneof"]  # noqa: Y015
    def WhichOneof(self, oneof_group: _WhichOneofArgType_a_oneof) -> _WhichOneofReturnType_a_oneof | None: ...

Global___Simple1: _TypeAlias = Simple1  # noqa: Y015

@_typing.final
class Simple2(_message.Message):
    DESCRIPTOR: _descriptor.Descriptor

    A_STRING_FIELD_NUMBER: _builtins.int
    a_string: _builtins.str
    def __init__(
        self,
        *,
        a_string: _builtins.str | None = ...,
    ) -> None: ...
    _HasFieldArgType: _TypeAlias = _typing.Literal["a_string", b"a_string"]  # noqa: Y015
    def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["a_string", b"a_string"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global___Simple2: _TypeAlias = Simple2  # noqa: Y015

@_typing.final
class Extensions1(_message.Message):
    DESCRIPTOR: _descriptor.Descriptor

    EXT1_STRING_FIELD_NUMBER: _builtins.int
    ext1_string: _builtins.str
    EXT_FIELD_NUMBER: _builtins.int
    ext: _extension_dict._ExtensionFieldDescriptor[Global___Simple1, Global___Extensions1]
    """ext"""
    def __init__(
        self,
        *,
        ext1_string: _builtins.str | None = ...,
    ) -> None: ...
    _HasFieldArgType: _TypeAlias = _typing.Literal["ext1_string", b"ext1_string"]  # noqa: Y015
    def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["ext1_string", b"ext1_string"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global___Extensions1: _TypeAlias = Extensions1  # noqa: Y015

@_typing.final
class Extensions2(_message.Message):
    DESCRIPTOR: _descriptor.Descriptor

    FLAG_FIELD_NUMBER: _builtins.int
    flag: _builtins.bool
    FOO_FIELD_NUMBER: _builtins.int
    foo: _extension_dict._ExtensionFieldDescriptor[Global___Simple1, Global___Extensions2]
    """foo"""
    def __init__(
        self,
        *,
        flag: _builtins.bool | None = ...,
    ) -> None: ...
    _HasFieldArgType: _TypeAlias = _typing.Literal["flag", b"flag"]  # noqa: Y015
    def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["flag", b"flag"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global___Extensions2: _TypeAlias = Extensions2  # noqa: Y015

@_typing.final
class _r_None(_message.Message):
    DESCRIPTOR: _descriptor.Descriptor

    VALID_FIELD_NUMBER: _builtins.int
    valid: _builtins.int
    def __init__(
        self,
        *,
        valid: _builtins.int | None = ...,
    ) -> None: ...
    _HasFieldArgType: _TypeAlias = _typing.Literal["valid", b"valid"]  # noqa: Y015
    def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["valid", b"valid"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global____r_None: _TypeAlias = _r_None  # noqa: Y015

@_typing.final
class PythonReservedKeywords(_message.Message):
    DESCRIPTOR: _descriptor.Descriptor

    class _finally:
        ValueType = _typing.NewType("ValueType", _builtins.int)
        V: _TypeAlias = ValueType  # noqa: Y015

    class _finallyEnumTypeWrapper(_enum_type_wrapper._EnumTypeWrapper[PythonReservedKeywords._finally.ValueType], _builtins.type):
        DESCRIPTOR: _descriptor.EnumDescriptor
        valid_in_finally: PythonReservedKeywords._finally.ValueType  # 2

    class _r_finally(_finally, metaclass=_finallyEnumTypeWrapper): ...
    valid_in_finally: PythonReservedKeywords._r_finally.ValueType  # 2

    @_typing.final
    class _r_lambda(_message.Message):
        DESCRIPTOR: _descriptor.Descriptor

        CONTINUE_FIELD_NUMBER: _builtins.int
        VALID_FIELD_NUMBER: _builtins.int
        valid: _builtins.int
        def __init__(
            self,
            *,
            valid: _builtins.int | None = ...,
        ) -> None: ...
        _HasFieldArgType: _TypeAlias = _typing.Literal["continue", b"continue", "valid", b"valid"]  # noqa: Y015
        def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
        _ClearFieldArgType: _TypeAlias = _typing.Literal["continue", b"continue", "valid", b"valid"]  # noqa: Y015
        def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

    FROM_FIELD_NUMBER: _builtins.int
    IN_FIELD_NUMBER: _builtins.int
    IS_FIELD_NUMBER: _builtins.int
    FOR_FIELD_NUMBER: _builtins.int
    TRY_FIELD_NUMBER: _builtins.int
    DEF_FIELD_NUMBER: _builtins.int
    NONLOCAL_FIELD_NUMBER: _builtins.int
    WHILE_FIELD_NUMBER: _builtins.int
    AND_FIELD_NUMBER: _builtins.int
    DEL_FIELD_NUMBER: _builtins.int
    GLOBAL_FIELD_NUMBER: _builtins.int
    NOT_FIELD_NUMBER: _builtins.int
    WITH_FIELD_NUMBER: _builtins.int
    AS_FIELD_NUMBER: _builtins.int
    ELIF_FIELD_NUMBER: _builtins.int
    IF_FIELD_NUMBER: _builtins.int
    OR_FIELD_NUMBER: _builtins.int
    YIELD_FIELD_NUMBER: _builtins.int
    ASSERT_FIELD_NUMBER: _builtins.int
    ELSE_FIELD_NUMBER: _builtins.int
    IMPORT_FIELD_NUMBER: _builtins.int
    PASS_FIELD_NUMBER: _builtins.int
    BREAK_FIELD_NUMBER: _builtins.int
    EXCEPT_FIELD_NUMBER: _builtins.int
    RAISE_FIELD_NUMBER: _builtins.int
    FALSE_FIELD_NUMBER: _builtins.int
    TRUE_FIELD_NUMBER: _builtins.int
    CLASS_FIELD_NUMBER: _builtins.int
    NONE_FIELD_NUMBER: _builtins.int
    VALID_FIELD_NUMBER: _builtins.int
    valid: Global___PythonReservedKeywords._r_finally.ValueType
    @_builtins.property
    def none(self) -> Global____r_None:
        """Test unreserved identifiers w/ reserved message names"""

    def __init__(
        self,
        *,
        none: Global____r_None | None = ...,
        valid: Global___PythonReservedKeywords._r_finally.ValueType | None = ...,
    ) -> None: ...
    _HasFieldArgType: _TypeAlias = _typing.Literal["False", b"False", "True", b"True", "and", b"and", "as", b"as", "assert", b"assert", "break", b"break", "class", b"class", "def", b"def", "del", b"del", "elif", b"elif", "else", b"else", "except", b"except", "for", b"for", "from", b"from", "global", b"global", "if", b"if", "import", b"import", "in", b"in", "is", b"is", "none", b"none", "nonlocal", b"nonlocal", "not", b"not", "or", b"or", "pass", b"pass", "raise", b"raise", "try", b"try", "valid", b"valid", "while", b"while", "with", b"with", "yield", b"yield"]  # noqa: Y015
    def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["False", b"False", "True", b"True", "and", b"and", "as", b"as", "assert", b"assert", "break", b"break", "class", b"class", "def", b"def", "del", b"del", "elif", b"elif", "else", b"else", "except", b"except", "for", b"for", "from", b"from", "global", b"global", "if", b"if", "import", b"import", "in", b"in", "is", b"is", "none", b"none", "nonlocal", b"nonlocal", "not", b"not", "or", b"or", "pass", b"pass", "raise", b"raise", "try", b"try", "valid", b"valid", "while", b"while", "with", b"with", "yield", b"yield"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global___PythonReservedKeywords: _TypeAlias = PythonReservedKeywords  # noqa: Y015

@_typing.final
class PythonReservedKeywordsSmall(_message.Message):
    """Do one with just one arg - to make sure it's syntactically correct"""

    DESCRIPTOR: _descriptor.Descriptor

    FROM_FIELD_NUMBER: _builtins.int
    def __init__(
        self,
    ) -> None: ...
    _HasFieldArgType: _TypeAlias = _typing.Literal["from", b"from"]  # noqa: Y015
    def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["from", b"from"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global___PythonReservedKeywordsSmall: _TypeAlias = PythonReservedKeywordsSmall  # noqa: Y015

@_typing.final
class SelfField(_message.Message):
    DESCRIPTOR: _descriptor.Descriptor

    SELF_FIELD_NUMBER: _builtins.int
    self: _builtins.int
    """Field self -> must generate an __init__ method w/ different name"""
    def __init__(
        self_,  # pyright: ignore[reportSelfClsParameterName]
        *,
        self: _builtins.int | None = ...,
    ) -> None: ...
    _HasFieldArgType: _TypeAlias = _typing.Literal["self", b"self"]  # noqa: Y015
    def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["self", b"self"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global___SelfField: _TypeAlias = SelfField  # noqa: Y015

@_deprecated("""This message is deprecated""")
@_typing.final
class DeprecatedMessage(_message.Message):
    DESCRIPTOR: _descriptor.Descriptor

    A_STRING_FIELD_NUMBER: _builtins.int
    DEPRECATED_FIELD_FIELD_NUMBER: _builtins.int
    DEPRECATED_FIELD_WITH_COMMENT_FIELD_NUMBER: _builtins.int
    a_string: _builtins.str
    @_builtins.property
    @_deprecated("""This field has been marked as deprecated using proto field options.""")
    def deprecated_field(self) -> _builtins.str: ...
    @deprecated_field.setter
    @_deprecated("""This field has been marked as deprecated using proto field options.""")
    def deprecated_field(self, value: _builtins.str) -> None: ...
    @_builtins.property
    @_deprecated("""This field has been marked as deprecated using proto field options.""")
    def deprecated_field_with_comment(self) -> _builtins.str:
        """This field is deprecated with comment"""

    @deprecated_field_with_comment.setter
    @_deprecated("""This field has been marked as deprecated using proto field options.""")
    def deprecated_field_with_comment(self, value: _builtins.str) -> None:
        """This field is deprecated with comment"""

    def __init__(
        self,
        *,
        a_string: _builtins.str | None = ...,
        deprecated_field: _builtins.str | None = ...,
        deprecated_field_with_comment: _builtins.str | None = ...,
    ) -> None: ...
    _HasFieldArgType: _TypeAlias = _typing.Literal["a_string", b"a_string", "deprecated_field", b"deprecated_field", "deprecated_field_with_comment", b"deprecated_field_with_comment"]  # noqa: Y015
    def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["a_string", b"a_string", "deprecated_field", b"deprecated_field", "deprecated_field_with_comment", b"deprecated_field_with_comment"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global___DeprecatedMessage: _TypeAlias = DeprecatedMessage  # noqa: Y015

@_deprecated("""This message has been marked as deprecated using proto message options.""")
@_typing.final
class DeprecatedMessageBadComment(_message.Message):
    DESCRIPTOR: _descriptor.Descriptor

    A_STRING_FIELD_NUMBER: _builtins.int
    a_string: _builtins.str
    def __init__(
        self,
        *,
        a_string: _builtins.str | None = ...,
    ) -> None: ...
    _HasFieldArgType: _TypeAlias = _typing.Literal["a_string", b"a_string"]  # noqa: Y015
    def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["a_string", b"a_string"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global___DeprecatedMessageBadComment: _TypeAlias = DeprecatedMessageBadComment  # noqa: Y015

@_typing.final
class TestDuplicatePackageMessage(_message.Message):
    DESCRIPTOR: _descriptor.Descriptor

    MSG_FIELD_NUMBER: _builtins.int
    @_builtins.property
    def msg(self) -> _test3_pb2_1.DuplicatePackageMessage: ...
    def __init__(
        self,
        *,
        msg: _test3_pb2_1.DuplicatePackageMessage | None = ...,
    ) -> None: ...
    _HasFieldArgType: _TypeAlias = _typing.Literal["msg", b"msg"]  # noqa: Y015
    def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["msg", b"msg"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global___TestDuplicatePackageMessage: _TypeAlias = TestDuplicatePackageMessage  # noqa: Y015
