"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
We don't put this in a package within proto2 because we need to make sure
that the generated code doesn't depend on being in the proto2 namespace.
"""

from collections import abc as _abc
from google.protobuf import any_pb2 as _any_pb2
from google.protobuf import descriptor as _descriptor
from google.protobuf import descriptor_pb2 as _descriptor_pb2
from google.protobuf import message as _message
from google.protobuf.internal import containers as _containers
from google.protobuf.internal import enum_type_wrapper as _enum_type_wrapper
from google.protobuf.internal import extension_dict as _extension_dict
import builtins as _builtins
import sys
import typing as _typing

if sys.version_info >= (3, 10):
    from typing import TypeAlias as _TypeAlias
else:
    from typing_extensions import TypeAlias as _TypeAlias

DESCRIPTOR: _descriptor.FileDescriptor

class _MethodOpt1:
    ValueType = _typing.NewType("ValueType", _builtins.int)
    V: _TypeAlias = ValueType  # noqa: Y015

class _MethodOpt1EnumTypeWrapper(_enum_type_wrapper._EnumTypeWrapper[_MethodOpt1.ValueType], _builtins.type):
    DESCRIPTOR: _descriptor.EnumDescriptor
    METHODOPT1_VAL1: _MethodOpt1.ValueType  # 1
    METHODOPT1_VAL2: _MethodOpt1.ValueType  # 2

class MethodOpt1(_MethodOpt1, metaclass=_MethodOpt1EnumTypeWrapper): ...

METHODOPT1_VAL1: MethodOpt1.ValueType  # 1
METHODOPT1_VAL2: MethodOpt1.ValueType  # 2
Global___MethodOpt1: _TypeAlias = MethodOpt1  # noqa: Y015

class _AggregateEnum:
    ValueType = _typing.NewType("ValueType", _builtins.int)
    V: _TypeAlias = ValueType  # noqa: Y015

class _AggregateEnumEnumTypeWrapper(_enum_type_wrapper._EnumTypeWrapper[_AggregateEnum.ValueType], _builtins.type):
    DESCRIPTOR: _descriptor.EnumDescriptor
    VALUE: _AggregateEnum.ValueType  # 1

class AggregateEnum(_AggregateEnum, metaclass=_AggregateEnumEnumTypeWrapper): ...

VALUE: AggregateEnum.ValueType  # 1
Global___AggregateEnum: _TypeAlias = AggregateEnum  # noqa: Y015

@_typing.final
class TestMessageWithCustomOptions(_message.Message):
    """A test message with custom options at all possible locations (and also some
    regular options, to make sure they interact nicely).
    """

    DESCRIPTOR: _descriptor.Descriptor

    class _AnEnum:
        ValueType = _typing.NewType("ValueType", _builtins.int)
        V: _TypeAlias = ValueType  # noqa: Y015

    class _AnEnumEnumTypeWrapper(_enum_type_wrapper._EnumTypeWrapper[TestMessageWithCustomOptions._AnEnum.ValueType], _builtins.type):
        DESCRIPTOR: _descriptor.EnumDescriptor
        ANENUM_VAL1: TestMessageWithCustomOptions._AnEnum.ValueType  # 1
        ANENUM_VAL2: TestMessageWithCustomOptions._AnEnum.ValueType  # 2

    class AnEnum(_AnEnum, metaclass=_AnEnumEnumTypeWrapper): ...
    ANENUM_VAL1: TestMessageWithCustomOptions.AnEnum.ValueType  # 1
    ANENUM_VAL2: TestMessageWithCustomOptions.AnEnum.ValueType  # 2

    @_typing.final
    class MapFieldEntry(_message.Message):
        DESCRIPTOR: _descriptor.Descriptor

        KEY_FIELD_NUMBER: _builtins.int
        VALUE_FIELD_NUMBER: _builtins.int
        key: _builtins.str
        value: _builtins.str
        def __init__(
            self,
            *,
            key: _builtins.str | None = ...,
            value: _builtins.str | None = ...,
        ) -> None: ...
        _HasFieldArgType: _TypeAlias = _typing.Literal["key", b"key", "value", b"value"]  # noqa: Y015
        def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
        _ClearFieldArgType: _TypeAlias = _typing.Literal["key", b"key", "value", b"value"]  # noqa: Y015
        def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

    FIELD1_FIELD_NUMBER: _builtins.int
    ONEOF_FIELD_FIELD_NUMBER: _builtins.int
    MAP_FIELD_FIELD_NUMBER: _builtins.int
    field1: _builtins.str
    oneof_field: _builtins.int
    @_builtins.property
    def map_field(self) -> _containers.ScalarMap[_builtins.str, _builtins.str]: ...
    def __init__(
        self,
        *,
        field1: _builtins.str | None = ...,
        oneof_field: _builtins.int | None = ...,
        map_field: _abc.Mapping[_builtins.str, _builtins.str] | None = ...,
    ) -> None: ...
    _HasFieldArgType: _TypeAlias = _typing.Literal["AnOneof", b"AnOneof", "field1", b"field1", "oneof_field", b"oneof_field"]  # noqa: Y015
    def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["AnOneof", b"AnOneof", "field1", b"field1", "map_field", b"map_field", "oneof_field", b"oneof_field"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...
    _WhichOneofReturnType_AnOneof: _TypeAlias = _typing.Literal["oneof_field"]  # noqa: Y015
    _WhichOneofArgType_AnOneof: _TypeAlias = _typing.Literal["AnOneof", b"AnOneof"]  # noqa: Y015
    def WhichOneof(self, oneof_group: _WhichOneofArgType_AnOneof) -> _WhichOneofReturnType_AnOneof | None: ...

Global___TestMessageWithCustomOptions: _TypeAlias = TestMessageWithCustomOptions  # noqa: Y015

@_typing.final
class CustomOptionFooRequest(_message.Message):
    """A test RPC service with custom options at all possible locations (and also
    some regular options, to make sure they interact nicely).
    """

    DESCRIPTOR: _descriptor.Descriptor

    def __init__(
        self,
    ) -> None: ...

Global___CustomOptionFooRequest: _TypeAlias = CustomOptionFooRequest  # noqa: Y015

@_typing.final
class CustomOptionFooResponse(_message.Message):
    DESCRIPTOR: _descriptor.Descriptor

    def __init__(
        self,
    ) -> None: ...

Global___CustomOptionFooResponse: _TypeAlias = CustomOptionFooResponse  # noqa: Y015

@_typing.final
class CustomOptionFooClientMessage(_message.Message):
    DESCRIPTOR: _descriptor.Descriptor

    def __init__(
        self,
    ) -> None: ...

Global___CustomOptionFooClientMessage: _TypeAlias = CustomOptionFooClientMessage  # noqa: Y015

@_typing.final
class CustomOptionFooServerMessage(_message.Message):
    DESCRIPTOR: _descriptor.Descriptor

    def __init__(
        self,
    ) -> None: ...

Global___CustomOptionFooServerMessage: _TypeAlias = CustomOptionFooServerMessage  # noqa: Y015

@_typing.final
class DummyMessageContainingEnum(_message.Message):
    """Options of every possible field type, so we can test them all exhaustively."""

    DESCRIPTOR: _descriptor.Descriptor

    class _TestEnumType:
        ValueType = _typing.NewType("ValueType", _builtins.int)
        V: _TypeAlias = ValueType  # noqa: Y015

    class _TestEnumTypeEnumTypeWrapper(_enum_type_wrapper._EnumTypeWrapper[DummyMessageContainingEnum._TestEnumType.ValueType], _builtins.type):
        DESCRIPTOR: _descriptor.EnumDescriptor
        TEST_OPTION_ENUM_TYPE1: DummyMessageContainingEnum._TestEnumType.ValueType  # 22
        TEST_OPTION_ENUM_TYPE2: DummyMessageContainingEnum._TestEnumType.ValueType  # -23

    class TestEnumType(_TestEnumType, metaclass=_TestEnumTypeEnumTypeWrapper): ...
    TEST_OPTION_ENUM_TYPE1: DummyMessageContainingEnum.TestEnumType.ValueType  # 22
    TEST_OPTION_ENUM_TYPE2: DummyMessageContainingEnum.TestEnumType.ValueType  # -23

    def __init__(
        self,
    ) -> None: ...

Global___DummyMessageContainingEnum: _TypeAlias = DummyMessageContainingEnum  # noqa: Y015

@_typing.final
class DummyMessageInvalidAsOptionType(_message.Message):
    DESCRIPTOR: _descriptor.Descriptor

    def __init__(
        self,
    ) -> None: ...

Global___DummyMessageInvalidAsOptionType: _TypeAlias = DummyMessageInvalidAsOptionType  # noqa: Y015

@_typing.final
class CustomOptionMinIntegerValues(_message.Message):
    DESCRIPTOR: _descriptor.Descriptor

    def __init__(
        self,
    ) -> None: ...

Global___CustomOptionMinIntegerValues: _TypeAlias = CustomOptionMinIntegerValues  # noqa: Y015

@_typing.final
class CustomOptionMaxIntegerValues(_message.Message):
    DESCRIPTOR: _descriptor.Descriptor

    def __init__(
        self,
    ) -> None: ...

Global___CustomOptionMaxIntegerValues: _TypeAlias = CustomOptionMaxIntegerValues  # noqa: Y015

@_typing.final
class CustomOptionOtherValues(_message.Message):
    DESCRIPTOR: _descriptor.Descriptor

    def __init__(
        self,
    ) -> None: ...

Global___CustomOptionOtherValues: _TypeAlias = CustomOptionOtherValues  # noqa: Y015

@_typing.final
class SettingRealsFromPositiveInts(_message.Message):
    DESCRIPTOR: _descriptor.Descriptor

    def __init__(
        self,
    ) -> None: ...

Global___SettingRealsFromPositiveInts: _TypeAlias = SettingRealsFromPositiveInts  # noqa: Y015

@_typing.final
class SettingRealsFromNegativeInts(_message.Message):
    DESCRIPTOR: _descriptor.Descriptor

    def __init__(
        self,
    ) -> None: ...

Global___SettingRealsFromNegativeInts: _TypeAlias = SettingRealsFromNegativeInts  # noqa: Y015

@_typing.final
class SettingRealsFromInf(_message.Message):
    DESCRIPTOR: _descriptor.Descriptor

    def __init__(
        self,
    ) -> None: ...

Global___SettingRealsFromInf: _TypeAlias = SettingRealsFromInf  # noqa: Y015

@_typing.final
class SettingRealsFromNegativeInf(_message.Message):
    DESCRIPTOR: _descriptor.Descriptor

    def __init__(
        self,
    ) -> None: ...

Global___SettingRealsFromNegativeInf: _TypeAlias = SettingRealsFromNegativeInf  # noqa: Y015

@_typing.final
class SettingRealsFromNan(_message.Message):
    DESCRIPTOR: _descriptor.Descriptor

    def __init__(
        self,
    ) -> None: ...

Global___SettingRealsFromNan: _TypeAlias = SettingRealsFromNan  # noqa: Y015

@_typing.final
class SettingRealsFromNegativeNan(_message.Message):
    DESCRIPTOR: _descriptor.Descriptor

    def __init__(
        self,
    ) -> None: ...

Global___SettingRealsFromNegativeNan: _TypeAlias = SettingRealsFromNegativeNan  # noqa: Y015

@_typing.final
class ComplexOptionType1(_message.Message):
    """Options of complex message types, themselves combined and extended in
    various ways.
    """

    DESCRIPTOR: _descriptor.Descriptor

    FOO_FIELD_NUMBER: _builtins.int
    FOO2_FIELD_NUMBER: _builtins.int
    FOO3_FIELD_NUMBER: _builtins.int
    FOO4_FIELD_NUMBER: _builtins.int
    foo: _builtins.int
    foo2: _builtins.int
    foo3: _builtins.int
    @_builtins.property
    def foo4(self) -> _containers.RepeatedScalarFieldContainer[_builtins.int]: ...
    def __init__(
        self,
        *,
        foo: _builtins.int | None = ...,
        foo2: _builtins.int | None = ...,
        foo3: _builtins.int | None = ...,
        foo4: _abc.Iterable[_builtins.int] | None = ...,
    ) -> None: ...
    _HasFieldArgType: _TypeAlias = _typing.Literal["foo", b"foo", "foo2", b"foo2", "foo3", b"foo3"]  # noqa: Y015
    def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["foo", b"foo", "foo2", b"foo2", "foo3", b"foo3", "foo4", b"foo4"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global___ComplexOptionType1: _TypeAlias = ComplexOptionType1  # noqa: Y015

@_typing.final
class ComplexOptionType2(_message.Message):
    DESCRIPTOR: _descriptor.Descriptor

    @_typing.final
    class ComplexOptionType4(_message.Message):
        DESCRIPTOR: _descriptor.Descriptor

        WALDO_FIELD_NUMBER: _builtins.int
        waldo: _builtins.int
        COMPLEX_OPT4_FIELD_NUMBER: _builtins.int
        complex_opt4: _extension_dict._ExtensionFieldDescriptor[_descriptor_pb2.MessageOptions, Global___ComplexOptionType2.ComplexOptionType4]
        def __init__(
            self,
            *,
            waldo: _builtins.int | None = ...,
        ) -> None: ...
        _HasFieldArgType: _TypeAlias = _typing.Literal["waldo", b"waldo"]  # noqa: Y015
        def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
        _ClearFieldArgType: _TypeAlias = _typing.Literal["waldo", b"waldo"]  # noqa: Y015
        def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

    BAR_FIELD_NUMBER: _builtins.int
    BAZ_FIELD_NUMBER: _builtins.int
    FRED_FIELD_NUMBER: _builtins.int
    BARNEY_FIELD_NUMBER: _builtins.int
    baz: _builtins.int
    @_builtins.property
    def bar(self) -> Global___ComplexOptionType1: ...
    @_builtins.property
    def fred(self) -> Global___ComplexOptionType2.ComplexOptionType4: ...
    @_builtins.property
    def barney(self) -> _containers.RepeatedCompositeFieldContainer[Global___ComplexOptionType2.ComplexOptionType4]: ...
    def __init__(
        self,
        *,
        bar: Global___ComplexOptionType1 | None = ...,
        baz: _builtins.int | None = ...,
        fred: Global___ComplexOptionType2.ComplexOptionType4 | None = ...,
        barney: _abc.Iterable[Global___ComplexOptionType2.ComplexOptionType4] | None = ...,
    ) -> None: ...
    _HasFieldArgType: _TypeAlias = _typing.Literal["bar", b"bar", "baz", b"baz", "fred", b"fred"]  # noqa: Y015
    def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["bar", b"bar", "barney", b"barney", "baz", b"baz", "fred", b"fred"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global___ComplexOptionType2: _TypeAlias = ComplexOptionType2  # noqa: Y015

@_typing.final
class ComplexOptionType3(_message.Message):
    DESCRIPTOR: _descriptor.Descriptor

    @_typing.final
    class ComplexOptionType5(_message.Message):
        DESCRIPTOR: _descriptor.Descriptor

        PLUGH_FIELD_NUMBER: _builtins.int
        plugh: _builtins.int
        def __init__(
            self,
            *,
            plugh: _builtins.int | None = ...,
        ) -> None: ...
        _HasFieldArgType: _TypeAlias = _typing.Literal["plugh", b"plugh"]  # noqa: Y015
        def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
        _ClearFieldArgType: _TypeAlias = _typing.Literal["plugh", b"plugh"]  # noqa: Y015
        def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

    MOO_FIELD_NUMBER: _builtins.int
    COMPLEXOPTIONTYPE5_FIELD_NUMBER: _builtins.int
    moo: _builtins.int
    @_builtins.property
    def complexoptiontype5(self) -> Global___ComplexOptionType3.ComplexOptionType5: ...
    def __init__(
        self,
        *,
        moo: _builtins.int | None = ...,
        complexoptiontype5: Global___ComplexOptionType3.ComplexOptionType5 | None = ...,
    ) -> None: ...
    _HasFieldArgType: _TypeAlias = _typing.Literal["complexoptiontype5", b"complexoptiontype5", "moo", b"moo"]  # noqa: Y015
    def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["complexoptiontype5", b"complexoptiontype5", "moo", b"moo"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global___ComplexOptionType3: _TypeAlias = ComplexOptionType3  # noqa: Y015

@_typing.final
class ComplexOpt6(_message.Message):
    DESCRIPTOR: _descriptor.Descriptor

    XYZZY_FIELD_NUMBER: _builtins.int
    xyzzy: _builtins.int
    def __init__(
        self,
        *,
        xyzzy: _builtins.int | None = ...,
    ) -> None: ...
    _HasFieldArgType: _TypeAlias = _typing.Literal["xyzzy", b"xyzzy"]  # noqa: Y015
    def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["xyzzy", b"xyzzy"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global___ComplexOpt6: _TypeAlias = ComplexOpt6  # noqa: Y015

@_typing.final
class VariousComplexOptions(_message.Message):
    """Note that we try various different ways of naming the same extension."""

    DESCRIPTOR: _descriptor.Descriptor

    def __init__(
        self,
    ) -> None: ...

Global___VariousComplexOptions: _TypeAlias = VariousComplexOptions  # noqa: Y015

@_typing.final
class AggregateMessageSet(_message.Message):
    """------------------------------------------------------
    Definitions for testing aggregate option parsing.
    See descriptor_unittest.cc.
    """

    DESCRIPTOR: _descriptor.Descriptor

    def __init__(
        self,
    ) -> None: ...

Global___AggregateMessageSet: _TypeAlias = AggregateMessageSet  # noqa: Y015

@_typing.final
class AggregateMessageSetElement(_message.Message):
    DESCRIPTOR: _descriptor.Descriptor

    S_FIELD_NUMBER: _builtins.int
    s: _builtins.str
    MESSAGE_SET_EXTENSION_FIELD_NUMBER: _builtins.int
    message_set_extension: _extension_dict._ExtensionFieldDescriptor[Global___AggregateMessageSet, Global___AggregateMessageSetElement]
    def __init__(
        self,
        *,
        s: _builtins.str | None = ...,
    ) -> None: ...
    _HasFieldArgType: _TypeAlias = _typing.Literal["s", b"s"]  # noqa: Y015
    def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["s", b"s"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global___AggregateMessageSetElement: _TypeAlias = AggregateMessageSetElement  # noqa: Y015

@_typing.final
class Aggregate(_message.Message):
    """A helper type used to test aggregate option parsing"""

    DESCRIPTOR: _descriptor.Descriptor

    I_FIELD_NUMBER: _builtins.int
    S_FIELD_NUMBER: _builtins.int
    SUB_FIELD_NUMBER: _builtins.int
    FILE_FIELD_NUMBER: _builtins.int
    MSET_FIELD_NUMBER: _builtins.int
    ANY_FIELD_NUMBER: _builtins.int
    i: _builtins.int
    s: _builtins.str
    @_builtins.property
    def sub(self) -> Global___Aggregate:
        """A nested object"""

    @_builtins.property
    def file(self) -> _descriptor_pb2.FileOptions:
        """To test the parsing of extensions inside aggregate values"""

    @_builtins.property
    def mset(self) -> Global___AggregateMessageSet:
        """An embedded message set"""

    @_builtins.property
    def any(self) -> _any_pb2.Any:
        """An any"""

    NESTED_FIELD_NUMBER: _builtins.int
    nested: _extension_dict._ExtensionFieldDescriptor[_descriptor_pb2.FileOptions, Global___Aggregate]
    def __init__(
        self,
        *,
        i: _builtins.int | None = ...,
        s: _builtins.str | None = ...,
        sub: Global___Aggregate | None = ...,
        file: _descriptor_pb2.FileOptions | None = ...,
        mset: Global___AggregateMessageSet | None = ...,
        any: _any_pb2.Any | None = ...,
    ) -> None: ...
    _HasFieldArgType: _TypeAlias = _typing.Literal["any", b"any", "file", b"file", "i", b"i", "mset", b"mset", "s", b"s", "sub", b"sub"]  # noqa: Y015
    def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["any", b"any", "file", b"file", "i", b"i", "mset", b"mset", "s", b"s", "sub", b"sub"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global___Aggregate: _TypeAlias = Aggregate  # noqa: Y015

@_typing.final
class AggregateMessage(_message.Message):
    DESCRIPTOR: _descriptor.Descriptor

    FIELDNAME_FIELD_NUMBER: _builtins.int
    fieldname: _builtins.int
    def __init__(
        self,
        *,
        fieldname: _builtins.int | None = ...,
    ) -> None: ...
    _HasFieldArgType: _TypeAlias = _typing.Literal["fieldname", b"fieldname"]  # noqa: Y015
    def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["fieldname", b"fieldname"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global___AggregateMessage: _TypeAlias = AggregateMessage  # noqa: Y015

@_typing.final
class NestedOptionType(_message.Message):
    """Test custom options for nested type."""

    DESCRIPTOR: _descriptor.Descriptor

    class _NestedEnum:
        ValueType = _typing.NewType("ValueType", _builtins.int)
        V: _TypeAlias = ValueType  # noqa: Y015

    class _NestedEnumEnumTypeWrapper(_enum_type_wrapper._EnumTypeWrapper[NestedOptionType._NestedEnum.ValueType], _builtins.type):
        DESCRIPTOR: _descriptor.EnumDescriptor
        NESTED_ENUM_VALUE: NestedOptionType._NestedEnum.ValueType  # 1

    class NestedEnum(_NestedEnum, metaclass=_NestedEnumEnumTypeWrapper): ...
    NESTED_ENUM_VALUE: NestedOptionType.NestedEnum.ValueType  # 1

    @_typing.final
    class NestedMessage(_message.Message):
        DESCRIPTOR: _descriptor.Descriptor

        NESTED_FIELD_FIELD_NUMBER: _builtins.int
        nested_field: _builtins.int
        def __init__(
            self,
            *,
            nested_field: _builtins.int | None = ...,
        ) -> None: ...
        _HasFieldArgType: _TypeAlias = _typing.Literal["nested_field", b"nested_field"]  # noqa: Y015
        def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
        _ClearFieldArgType: _TypeAlias = _typing.Literal["nested_field", b"nested_field"]  # noqa: Y015
        def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

    NESTED_EXTENSION_FIELD_NUMBER: _builtins.int
    nested_extension: _extension_dict._ExtensionFieldDescriptor[_descriptor_pb2.FileOptions, _builtins.int]
    def __init__(
        self,
    ) -> None: ...

Global___NestedOptionType: _TypeAlias = NestedOptionType  # noqa: Y015

@_typing.final
class OldOptionType(_message.Message):
    """Custom message option that has a required enum field.
    WARNING: this is strongly discouraged!
    """

    DESCRIPTOR: _descriptor.Descriptor

    class _TestEnum:
        ValueType = _typing.NewType("ValueType", _builtins.int)
        V: _TypeAlias = ValueType  # noqa: Y015

    class _TestEnumEnumTypeWrapper(_enum_type_wrapper._EnumTypeWrapper[OldOptionType._TestEnum.ValueType], _builtins.type):
        DESCRIPTOR: _descriptor.EnumDescriptor
        OLD_VALUE: OldOptionType._TestEnum.ValueType  # 0

    class TestEnum(_TestEnum, metaclass=_TestEnumEnumTypeWrapper): ...
    OLD_VALUE: OldOptionType.TestEnum.ValueType  # 0

    VALUE_FIELD_NUMBER: _builtins.int
    value: Global___OldOptionType.TestEnum.ValueType
    def __init__(
        self,
        *,
        value: Global___OldOptionType.TestEnum.ValueType | None = ...,
    ) -> None: ...
    _HasFieldArgType: _TypeAlias = _typing.Literal["value", b"value"]  # noqa: Y015
    def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["value", b"value"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global___OldOptionType: _TypeAlias = OldOptionType  # noqa: Y015

@_typing.final
class NewOptionType(_message.Message):
    """Updated version of the custom option above."""

    DESCRIPTOR: _descriptor.Descriptor

    class _TestEnum:
        ValueType = _typing.NewType("ValueType", _builtins.int)
        V: _TypeAlias = ValueType  # noqa: Y015

    class _TestEnumEnumTypeWrapper(_enum_type_wrapper._EnumTypeWrapper[NewOptionType._TestEnum.ValueType], _builtins.type):
        DESCRIPTOR: _descriptor.EnumDescriptor
        OLD_VALUE: NewOptionType._TestEnum.ValueType  # 0
        NEW_VALUE: NewOptionType._TestEnum.ValueType  # 1

    class TestEnum(_TestEnum, metaclass=_TestEnumEnumTypeWrapper): ...
    OLD_VALUE: NewOptionType.TestEnum.ValueType  # 0
    NEW_VALUE: NewOptionType.TestEnum.ValueType  # 1

    VALUE_FIELD_NUMBER: _builtins.int
    value: Global___NewOptionType.TestEnum.ValueType
    def __init__(
        self,
        *,
        value: Global___NewOptionType.TestEnum.ValueType | None = ...,
    ) -> None: ...
    _HasFieldArgType: _TypeAlias = _typing.Literal["value", b"value"]  # noqa: Y015
    def HasField(self, field_name: _HasFieldArgType) -> _builtins.bool: ...
    _ClearFieldArgType: _TypeAlias = _typing.Literal["value", b"value"]  # noqa: Y015
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global___NewOptionType: _TypeAlias = NewOptionType  # noqa: Y015

@_typing.final
class TestMessageWithRequiredEnumOption(_message.Message):
    """Test message using the "required_enum_opt" option defined above."""

    DESCRIPTOR: _descriptor.Descriptor

    def __init__(
        self,
    ) -> None: ...

Global___TestMessageWithRequiredEnumOption: _TypeAlias = TestMessageWithRequiredEnumOption  # noqa: Y015

FILE_OPT1_FIELD_NUMBER: _builtins.int
MESSAGE_OPT1_FIELD_NUMBER: _builtins.int
FIELD_OPT1_FIELD_NUMBER: _builtins.int
FIELD_OPT2_FIELD_NUMBER: _builtins.int
ONEOF_OPT1_FIELD_NUMBER: _builtins.int
ENUM_OPT1_FIELD_NUMBER: _builtins.int
ENUM_VALUE_OPT1_FIELD_NUMBER: _builtins.int
SERVICE_OPT1_FIELD_NUMBER: _builtins.int
METHOD_OPT1_FIELD_NUMBER: _builtins.int
BOOL_OPT_FIELD_NUMBER: _builtins.int
INT32_OPT_FIELD_NUMBER: _builtins.int
INT64_OPT_FIELD_NUMBER: _builtins.int
UINT32_OPT_FIELD_NUMBER: _builtins.int
UINT64_OPT_FIELD_NUMBER: _builtins.int
SINT32_OPT_FIELD_NUMBER: _builtins.int
SINT64_OPT_FIELD_NUMBER: _builtins.int
FIXED32_OPT_FIELD_NUMBER: _builtins.int
FIXED64_OPT_FIELD_NUMBER: _builtins.int
SFIXED32_OPT_FIELD_NUMBER: _builtins.int
SFIXED64_OPT_FIELD_NUMBER: _builtins.int
FLOAT_OPT_FIELD_NUMBER: _builtins.int
DOUBLE_OPT_FIELD_NUMBER: _builtins.int
STRING_OPT_FIELD_NUMBER: _builtins.int
BYTES_OPT_FIELD_NUMBER: _builtins.int
ENUM_OPT_FIELD_NUMBER: _builtins.int
MESSAGE_TYPE_OPT_FIELD_NUMBER: _builtins.int
MOOO_FIELD_NUMBER: _builtins.int
CORGE_FIELD_NUMBER: _builtins.int
GRAULT_FIELD_NUMBER: _builtins.int
GARPLY_FIELD_NUMBER: _builtins.int
COMPLEX_OPT1_FIELD_NUMBER: _builtins.int
COMPLEX_OPT2_FIELD_NUMBER: _builtins.int
COMPLEX_OPT3_FIELD_NUMBER: _builtins.int
COMPLEXOPT6_FIELD_NUMBER: _builtins.int
FILEOPT_FIELD_NUMBER: _builtins.int
MSGOPT_FIELD_NUMBER: _builtins.int
FIELDOPT_FIELD_NUMBER: _builtins.int
ENUMOPT_FIELD_NUMBER: _builtins.int
ENUMVALOPT_FIELD_NUMBER: _builtins.int
SERVICEOPT_FIELD_NUMBER: _builtins.int
METHODOPT_FIELD_NUMBER: _builtins.int
REQUIRED_ENUM_OPT_FIELD_NUMBER: _builtins.int
file_opt1: _extension_dict._ExtensionFieldDescriptor[_descriptor_pb2.FileOptions, _builtins.int]
message_opt1: _extension_dict._ExtensionFieldDescriptor[_descriptor_pb2.MessageOptions, _builtins.int]
field_opt1: _extension_dict._ExtensionFieldDescriptor[_descriptor_pb2.FieldOptions, _builtins.int]
field_opt2: _extension_dict._ExtensionFieldDescriptor[_descriptor_pb2.FieldOptions, _builtins.int]
"""This is useful for testing that we correctly register default values for
extension options.
"""
oneof_opt1: _extension_dict._ExtensionFieldDescriptor[_descriptor_pb2.OneofOptions, _builtins.int]
enum_opt1: _extension_dict._ExtensionFieldDescriptor[_descriptor_pb2.EnumOptions, _builtins.int]
enum_value_opt1: _extension_dict._ExtensionFieldDescriptor[_descriptor_pb2.EnumValueOptions, _builtins.int]
service_opt1: _extension_dict._ExtensionFieldDescriptor[_descriptor_pb2.ServiceOptions, _builtins.int]
method_opt1: _extension_dict._ExtensionFieldDescriptor[_descriptor_pb2.MethodOptions, Global___MethodOpt1.ValueType]
bool_opt: _extension_dict._ExtensionFieldDescriptor[_descriptor_pb2.MessageOptions, _builtins.bool]
int32_opt: _extension_dict._ExtensionFieldDescriptor[_descriptor_pb2.MessageOptions, _builtins.int]
int64_opt: _extension_dict._ExtensionFieldDescriptor[_descriptor_pb2.MessageOptions, _builtins.int]
uint32_opt: _extension_dict._ExtensionFieldDescriptor[_descriptor_pb2.MessageOptions, _builtins.int]
uint64_opt: _extension_dict._ExtensionFieldDescriptor[_descriptor_pb2.MessageOptions, _builtins.int]
sint32_opt: _extension_dict._ExtensionFieldDescriptor[_descriptor_pb2.MessageOptions, _builtins.int]
sint64_opt: _extension_dict._ExtensionFieldDescriptor[_descriptor_pb2.MessageOptions, _builtins.int]
fixed32_opt: _extension_dict._ExtensionFieldDescriptor[_descriptor_pb2.MessageOptions, _builtins.int]
fixed64_opt: _extension_dict._ExtensionFieldDescriptor[_descriptor_pb2.MessageOptions, _builtins.int]
sfixed32_opt: _extension_dict._ExtensionFieldDescriptor[_descriptor_pb2.MessageOptions, _builtins.int]
sfixed64_opt: _extension_dict._ExtensionFieldDescriptor[_descriptor_pb2.MessageOptions, _builtins.int]
float_opt: _extension_dict._ExtensionFieldDescriptor[_descriptor_pb2.MessageOptions, _builtins.float]
double_opt: _extension_dict._ExtensionFieldDescriptor[_descriptor_pb2.MessageOptions, _builtins.float]
string_opt: _extension_dict._ExtensionFieldDescriptor[_descriptor_pb2.MessageOptions, _builtins.str]
bytes_opt: _extension_dict._ExtensionFieldDescriptor[_descriptor_pb2.MessageOptions, _builtins.bytes]
enum_opt: _extension_dict._ExtensionFieldDescriptor[_descriptor_pb2.MessageOptions, Global___DummyMessageContainingEnum.TestEnumType.ValueType]
message_type_opt: _extension_dict._ExtensionFieldDescriptor[_descriptor_pb2.MessageOptions, Global___DummyMessageInvalidAsOptionType]
mooo: _extension_dict._ExtensionFieldDescriptor[Global___ComplexOptionType1, _builtins.int]
corge: _extension_dict._ExtensionFieldDescriptor[Global___ComplexOptionType1, Global___ComplexOptionType3]
grault: _extension_dict._ExtensionFieldDescriptor[Global___ComplexOptionType2, _builtins.int]
garply: _extension_dict._ExtensionFieldDescriptor[Global___ComplexOptionType2, Global___ComplexOptionType1]
complex_opt1: _extension_dict._ExtensionFieldDescriptor[_descriptor_pb2.MessageOptions, Global___ComplexOptionType1]
complex_opt2: _extension_dict._ExtensionFieldDescriptor[_descriptor_pb2.MessageOptions, Global___ComplexOptionType2]
complex_opt3: _extension_dict._ExtensionFieldDescriptor[_descriptor_pb2.MessageOptions, Global___ComplexOptionType3]
complexopt6: _extension_dict._ExtensionFieldDescriptor[_descriptor_pb2.MessageOptions, Global___ComplexOpt6]
fileopt: _extension_dict._ExtensionFieldDescriptor[_descriptor_pb2.FileOptions, Global___Aggregate]
msgopt: _extension_dict._ExtensionFieldDescriptor[_descriptor_pb2.MessageOptions, Global___Aggregate]
fieldopt: _extension_dict._ExtensionFieldDescriptor[_descriptor_pb2.FieldOptions, Global___Aggregate]
enumopt: _extension_dict._ExtensionFieldDescriptor[_descriptor_pb2.EnumOptions, Global___Aggregate]
enumvalopt: _extension_dict._ExtensionFieldDescriptor[_descriptor_pb2.EnumValueOptions, Global___Aggregate]
serviceopt: _extension_dict._ExtensionFieldDescriptor[_descriptor_pb2.ServiceOptions, Global___Aggregate]
methodopt: _extension_dict._ExtensionFieldDescriptor[_descriptor_pb2.MethodOptions, Global___Aggregate]
required_enum_opt: _extension_dict._ExtensionFieldDescriptor[_descriptor_pb2.MessageOptions, Global___OldOptionType]
